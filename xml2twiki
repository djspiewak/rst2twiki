#!/bin/sh
exec scala $0 $@
!#

import scala.xml._

def getBullet(node: Node) = (node \ "@enumtype").text match {
  case "arabic" => "1."
  case "loweralpha" => "a."
  case "upperalpha" => "A."
  case "lowerroman" => "i."
  case "upperroman" => "I."
  
  case x => error("Unrecognized enumtype: " + x)
}

def processId(id: String) = {
  if (id.length < 4)
    error("Invalid id (" + id + "). Must have length of at least 4.")
  
  "" + id(0).toUpperCase + id(1).toLowerCase + id(2).toUpperCase + id.substring(3)
}

def processText(text: String) = {
  (text flatMap {
    case '&' => "&amp;"
    case '<' => "&lt;"
    case '>' => "&gt;"
    case '!' => "&#33;"
    case '%' => "&#37;"
    case '[' => "&#91;"
    case c => c.toString
  }).mkString
}

def processParagraph(nodes: NodeSeq): String = {
  var result = ""
  nodes foreach {
    case Text(contents) => {
      result += (processText(contents) split "\n" map { _.trim } mkString "\n") + ' '
    }
    
    case <emphasis>{contents}</emphasis> => {
      result += '_' + processText(contents.text) + '_'
    }
    
    case <strong>{contents}</strong> => {
      result += "*" + processText(contents.text) + "*"
    }
    
    case <literal>{contents}</literal> => {
      result += "=" + contents.text + "="
    }
    
    case node @ <reference>{contents}</reference> => {
      val link = {
        val back = node \ "@refuri"
        
        if (back.length == 0)
          "#" + processId((node \ "@refid").text)
        else
          back
      }
      
      result += "[[" + link + "][" + processText(contents.text) + "]]"
    }
    
    case <title_reference>{contents}</title_reference> => {
      result += "%" + contents.text + "%"
    }
    
    case x => error("Unrecognized fragment: " + x)
  }
  
  result + '\n'
}

def processList(bullet: String, level: Int, nodes: NodeSeq): String = {
  val padding = (0 until level).foldLeft("") { (str, _) => str + ' ' }
  
  var result = ""
  nodes foreach {
    case <list_item>{contents @ _*}</list_item> => {
      var first = true
      
      contents foreach {
        case <paragraph>{contents @ _*}</paragraph> => {
          if (!first)
            error("Only one paragraph allowed per list_item")
          
          result += padding + bullet + ' '
          result += {
            val lines = processParagraph(contents).split('\n')
            lines.mkString("\n" + padding + "  ")
          } + '\n'
          
          first = false
        }
        
        case <bullet_list>{contents @ _*}</bullet_list> => {
          result += processList("*", level + 3, contents)
        }
        
        case node @ <enumerated_list>{contents @ _*}</enumerated_list> => {
          result += processList(getBullet(node), level + 3, contents)
        }
        
        case x => error("Unrecognized fragment: " + x)
      }
    }
    
    case x => error("Unrecognized fragment: " + x)
  }
  
  result
}

def processSection(level: Int, nodes: NodeSeq): String = {
  if (level > 6) 
    error("Invalid header level: " + level)
  
  var result = ""
  nodes foreach {
    case <title>{contents @ _*}</title> => {
      result += (0 to level).foldLeft("---") { (str, _) => str + '+' }
      result += ' ' + processParagraph(contents) + "\n"
    }
    
    case <paragraph>{contents @ _*}</paragraph> => {
      result += processParagraph(contents) + '\n'
    }
    
    case <bullet_list>{contents @ _*}</bullet_list> => {
      result += processList("*", 3, contents) + '\n'
    }
    
    case node @ <enumerated_list>{contents @ _*}</enumerated_list> => {
      result += processList(getBullet(node), 3, contents) + '\n'
    }
    
    case <literal_block>{contents}</literal_block> => {
      result += "<verbatim>\n"
      result += contents.text + '\n'
      result += "</verbatim>\n\n"
    }
    
    case <section>{contents @ _*}</section> => {
      result += processSection(level + 1, contents)
    }
    
    case node @ <target></target> => {
      val id = node \ "@refid"
      
      if (id.length > 0) {
        result += '#' + processId(id.text) + '\n'
      }
    }
    
    case <comment>{_*}</comment> => ()
    
    case <substitution_definition></substitution_definition> => ()
    
    case x => error("Unrecognized fragment: " + x)
  }
  
  result
}

val input = System.in
val output = System.out

val (<document>{document @ _*}</document>) = XML.load(input)
val result = try {
  processSection(0, document)
} catch {
  case t => {
    System.err.println(t.getMessage)
    exit(100)
  }
}

output.println("<noautolink>")
output.print(result)
output.println("</noautolink>")

// :mode=scala:
